package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"errors"
	"fmt"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/joho/godotenv"
	"grapgQL/database"
	"grapgQL/dbhelper"
	"grapgQL/graph/model"
	"log"
	"net/http"
	"os"
	"time"

	_ "github.com/99designs/gqlgen/handler"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	var user model.User
	user.FirstName = input.FirstName
	user.LastName = input.LastName
	user.Dob = input.Dob
	user.Phone = input.Phone
	user.Email = input.Email
	user.Password = input.Password

	_, err := r.DAO.CreateUser(&user)
	if err != nil {
		logrus.Println("CreateUser:failed to create user", err)
	}
	return &user, nil
}

// UploadProfileImage is the resolver for the uploadProfileImage field.
func (r *mutationResolver) UploadProfileImage(ctx context.Context, input model.NewProfileImage) (bool, error) {
	err := godotenv.Load(".env")
	if err != nil {
		return false, fmt.Errorf("ImageUpload: Error loading .env file: %w", err)
	}

	stream := input.File.File
	fileName := input.File.Filename

	sess, err := session.NewSession(&aws.Config{
		Region: aws.String(os.Getenv("AWS_REGION")),
		Credentials: credentials.NewStaticCredentials(
			os.Getenv("AWS_ACCESS_KEY_ID"),
			os.Getenv("AWS_SECRET_ACCESS_KEY"),
			""),
	})
	if err != nil {
		return false, fmt.Errorf("UploadImage: Error creating AWS session: %w", err)
	}

	svc := s3.New(sess)

	//fileName := fmt.Sprintf("%d-%s", time.Now().Unix(), fileName)

	bucketName := os.Getenv("S3_BUCKET_NAME")

	_, err = svc.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(bucketName),
		Key:    aws.String(fileName),
		Body:   stream,
	})
	if err != nil {
		return false, fmt.Errorf("UploadImage: Error uploading file to S3: %w", err)
	}

	image := model.Image{
		BucketName: bucketName,
		Path:       fileName,
		UserId:     input.UserID, // Assuming input has a field for UserID
	}

	uploadID, err := r.DAO.UploadImage(image)
	if err != nil {
		return false, fmt.Errorf("UploadImage: Error uploading image: %w", err)
	}

	if uploadID == nil {
		return false, errors.New("UploadImage: Failed to get upload ID")
	}

	return true, nil
}

// CreateLink is the resolver for the createLink field.
func (r *mutationResolver) CreateLink(ctx context.Context, input *model.NewLink) (*model.Link, error) {
	var link model.Link
	link.Title = input.Title
	link.Address = input.Address
	link.User = input.UserID

	_, err := r.DAO.CreateLink(&link)
	if err != nil {
		logrus.Println("CreateLink:failed to create link", err)
	}
	return &link, nil
}

func LoginHandler(w http.ResponseWriter, r *http.Request) {
	// Retrieve the user input from the request body or URL parameters
	email := r.FormValue("email")
	password := r.FormValue("password")

	// Create an instance of the mutationResolver
	resolver := &mutationResolver{}

	// Call your existing login resolver function to handle the login logic
	token, err := resolver.Login(context.Background(), model.Login{Email: email, Password: password})
	if err != nil {
		// Handle the login error
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}

	// Respond with the generated token
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(token))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	result, err := r.DAO.GetUserByEmail(input.Email)
	if err != nil {
		log.Println("Failed to retrieve user:", err)
		return "", fmt.Errorf("failed to retrieve user: %v", err)
	}
	if result == nil {
		return "", fmt.Errorf("user not found")
	}
	// Compare the passwords
	if input.Password != result.Password {
		return "", fmt.Errorf("incorrect password")
	}
	// Parse the string into a UUID object
	uuidObj, err := uuid.Parse(result.ID)
	if err != nil {
		// Handle error if the string is not a valid UUID
		fmt.Println("Invalid UUID:", err)
	}
	// Create a user session
	session := &dbhelper.UserSession{}
	token, _ := session.CreateUserSession(database.DB, &model.UserSession{
		UserID:   uuidObj,
		ExpiryAt: time.Now(),
	})
	if err != nil {
		log.Println("Failed to generate token:", err)
		return "", fmt.Errorf("failed to generate token: %v", err)
	}

	return token, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (string, error) {
	// Retrieve the refresh token from the input
	refreshToken := input.Token
	// Validate the refresh token and retrieve the associated user ID
	// verify session with token
	userId, err := dbhelper.VerifySession(&refreshToken)
	if err != nil {
		logrus.WithError(err).Errorf("failed to get user with token: %s", refreshToken)
		return "", fmt.Errorf("failed to get user with  token: %v", err)
	}
	if userId == nil {
		logrus.WithError(err).Errorf("failed to get user with token: %s", refreshToken)
		return "", fmt.Errorf("failed to get user with  token: %v", err)
	}
	// Parse the string into a UUID object
	uuidObj, err := uuid.Parse(userId.ID)
	if err != nil {
		// Handle error if the string is not a valid UUID
		fmt.Println("Invalid UUID:", err)
		return "", fmt.Errorf("Invalid UUID ", err)
	}
	// Generate a new access token
	session := &dbhelper.UserSession{}
	accessToken, _ := session.CreateUserSession(database.DB, &model.UserSession{
		UserID:   uuidObj,
		ExpiryAt: time.Now(),
	})
	if err != nil {
		fmt.Println("failed to generate token", err)

		return "", fmt.Errorf("failed to generate access token: %v", err)
	}

	return accessToken, nil
}

// RemoveUser is the resolver for the removeUser field.
func (r *mutationResolver) RemoveUser(ctx context.Context, input model.DeleteUser) (*model.User, error) {
	// Call the DeleteUser function

	err := r.DAO.DeleteUser(input.ID)
	if err != nil {
		log.Println("failed to delete user entry", err)
	}
	user := &model.User{
		ID: input.ID,
	}
	return user, err
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUser) (*model.User, error) {
	var user model.User
	user.FirstName = input.FirstName
	user.LastName = input.LastName
	user.Dob = input.Dob
	user.Phone = input.Phone
	user.Email = input.Email
	user.ID = input.ID

	err := r.DAO.UpdateUser(&user, user.ID)
	if err != nil {
		logrus.Println("UpdateUser:failed to update user", err)
	}
	return &user, nil
}

// Links is the resolver for the links field.
func (r *queryResolver) Links(ctx context.Context) ([]*model.Link, error) {
	// Create an instance of the link struct
	var link []*model.Link
	// Call the Get all link function

	result, err := r.DAO.GetAllLink(link)
	if err != nil {
		logrus.Println("links:failed to get all links")
		return nil, err
	}
	return result, nil
}

// Link is the resolver for the link field.
func (r *queryResolver) Link(ctx context.Context, id string) (*model.Link, error) {
	// create an instance of the link struct
	var link model.Link
	// call the get by id function

	result, err := r.DAO.GetLinkById(link, id)
	if err != nil {
		logrus.Println("Link:failed to get link by id ", err)
		return nil, err
	}
	return result, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// Create an instance of the User struct
	var user []*model.User
	// Call the Get all user function

	result, err := r.DAO.GetAllUser(user)
	if err != nil {
		logrus.Println("Users:failed to get all user")
		return nil, err
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Create an instance of the User struct
	user := model.User{}
	// Call the Get user by id function

	result, err := r.DAO.GetUserById(user, id)
	if err != nil {
		logrus.Println("Users:failed to get user by id")
		return nil, err
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
